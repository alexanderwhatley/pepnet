# Copyright (c) 2017. Mount Sinai School of Medicine
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import numpy as np

from .encoder import Encoder
from .amino_acids import amino_acids_dict, amino_acids_with_ptms_dict

amino_acid_encoder = Encoder(amino_acids)
amino_acid_letters = amino_acid_encoder.letters()

###
# Allow 'X' for amino acids whose identity is not known
###
amino_acids_with_unknown = amino_acids.copy()
amino_acids_with_unknown["X"] = "Unknown"
amino_acid_encoder_with_unknown = Encoder(amino_acids_with_unknown)
amino_acid_letters_with_unknown = amino_acid_encoder_with_unknown.letters()

###
# In cases where a sequence might have both unknown AAs and a gap
# we need to distinguish the two characters.
###
amino_acids_with_unknown_and_gap = amino_acids_with_unknown.copy()
amino_acids_with_unknown_and_gap["-"] = "Gap"
amino_acid_encoder_with_unknown_and_gap = Encoder(amino_acids_with_unknown_and_gap)
amino_acid_letters_with_unknown_and_gap = \
    amino_acid_encoder_with_unknown_and_gap.letters()




def sequences_to_indices(
        sequences,
        alphabet,
        add_start_symbol=True,
        add_end_symbol=True):
    """
    Encode sequences of symbols as sequences of integer indices starting from 1.

    Parameters
    ----------

    sequences : list of str

    index_dict : dict
        Mapping from symbols to indices (expected to start from 0)

    add_start_symbol : bool

    add_end_symbol : bool
    """

    max_value = len(alphabet)
    if add_start_symbol:
        max_value += 1
        prefix = [max_value]
        index_sequences = [prefix + seq for seq in index_sequences]
    if add_end_symbol:
        max_value += 1
        suffix = [max_value]
        index_sequences = [seq + suffix for seq in index_sequences]
    return index_sequences

def padded_indices(
        sequences,
        alphabet,
        ndim=2,
        padding='pre',
        add_start_symbol=True,
        add_end_symbol=True):
    """
    Given a list of strings, construct a list of index sequences
    and then pad them to make an array.
    """
    index_sequences = sequences_to_indices(
        sequences=sequences,
        index_dict=index_dict,
        add_start_symbol=add_start_symbol,
        add_end_symbol=add_end_symbol)

    max_len = max(len(s) for s in index_sequences)
    n_samples = len(index_sequences)
    if ndim < 2:
        raise ValueError("Padded input must have at least 2 dims")

    shape = (n_samples, max_len) + (1,) * (ndim - 2)
    result = np.zeros(shape, dtype=int)
    for i, x in enumerate(index_sequences):
        if padding == 'post':
            result[i, :len(x)] = x
        elif padding == 'pre':
            result[i, -len(x):] = x
    return result

def onehot(sequences, index_dict=None):
    """
    Parameters
    ----------
    sequences : list of strings

    index_dict : dict
        Mapping from symbols to integer indices
    """
    n_seq = len(sequences)
    if index_dict is None:
        index_dict = _build_index_dict(sequences)
    n_symbols = len(index_dict)
    maxlen = max(len(seq) for seq in sequences)
    result = np.zeros((n_seq, maxlen, n_symbols), dtype=bool)
    for i, seq in enumerate(sequences):
        for j, sj in enumerate(seq):
            result[i, j, index_dict[sj]] = 1
    return result


def padded_indices_to_next_symbol_as_output(X, padding='pre'):
    """
    Parameters
    ----------
    X : 2D Numpy array, generated by padded_indices
    """
    # just in case it comes in as something other than a np.array
    X = np.array(X)
    d = X.shape[1]
    # calculating how many samples will be made from each input row
    samples_in_row = []
    for row in X:
        samples_in_row.append((np.sum(row > 0) - 1))

    # pre-allocating input and output
    total_output_samples = sum(samples_in_row)
    X_out = np.zeros((total_output_samples, d - 1))
    y_out = np.zeros(total_output_samples)
    counter = 0
    for i, row in enumerate(X):
        samp_row_adj = samples_in_row[i] + 1
        for j in range(1, samp_row_adj):
            if padding == 'post':
                X_out[counter, :j] = row[:j]
                y_out[counter] = row[j]
            elif padding == 'pre':
                X_out[counter, -j:] = row[-samp_row_adj:-samp_row_adj + j]
                y_out[counter] = row[-samp_row_adj + j]
            counter += 1

    return X_out, y_out
